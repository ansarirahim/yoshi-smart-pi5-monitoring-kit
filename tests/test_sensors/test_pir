# --- Insert near top where you import the GPIO library used by MotionSensor ---
# (Assuming MotionSensor uses RPi.GPIO internally; if not, adapt accordingly)

def run_interactive_test(gpio_pin=17):
    """Run interactive PIR sensor test - safer & corrected sampling."""
    # ... (intro prints unchanged) ...

    sensor = MotionSensor(gpio_pin=gpio_pin)
    print(f"[{ts()}] Initializing GPIO{gpio_pin}...")

    # ensure MotionSensor.initialize() sets pull_down; otherwise set here if accessible:
    if not sensor.initialize(pull="down" if hasattr(sensor, "initialize") else None):
        print(f"[{ts()}] ‚ùå FAILED - Cannot initialize GPIO!")
        return False

    print(f"[{ts()}] ‚úì GPIO{gpio_pin} ready\n")

    # --- TEST 1: Idle State (corrected) ---
    print("‚îÅ" * 65)
    print("TEST 1: IDLE STATE CHECK")
    print("‚îÅ" * 65)
    print("üëâ Please stand still / don't move near the sensor...")

    idle_readings = []
    sample_count = 30
    sample_interval = 0.1  # seconds

    for _ in range(sample_count):
        val = sensor.is_motion_detected()
        idle_readings.append(1 if val else 0)
        time.sleep(sample_interval)

    idle_ratio = sum(idle_readings) / len(idle_readings) if idle_readings else 0.0
    test1_pass = idle_ratio < 0.3

    print(f"[{ts()}] idle ratio: {idle_ratio:.2f} ({sum(idle_readings)}/{len(idle_readings)})")
    if test1_pass:
        print(f"[{ts()}] ‚úÖ TEST 1 PASSED - Sensor is IDLE")
    else:
        print(f"[{ts()}] ‚ö†Ô∏è  TEST 1 WARNING - Sensor showing motion during idle")
    print()

    # --- TEST 2: Motion Detection (unchanged but with small debounce) ---
    print("‚îÅ" * 65)
    print("TEST 2: MOTION DETECTION")
    print("‚îÅ" * 65)
    print("üëâ Wave your hand in front of the sensor NOW!")

    motion_detected = False
    timeout_secs = 10
    deadline = time.time() + timeout_secs
    while time.time() < deadline:
        # require 2 consecutive HIGHs within sample_interval to avoid single-spike triggers
        if sensor.is_motion_detected():
            time.sleep(0.05)
            if sensor.is_motion_detected():
                motion_detected = True
                print(f"[{ts()}] üö® MOTION DETECTED!")
                break
        time.sleep(0.05)

    test2_pass = motion_detected
    if test2_pass:
        print(f"[{ts()}] ‚úÖ TEST 2 PASSED - Motion detection working!")
    else:
        print(f"[{ts()}] ‚ùå TEST 2 FAILED - No motion detected")
    print()

    # --- TEST 3: SIGNAL RECOVERY (corrected loop & debounce) ---
    print("‚îÅ" * 65)
    print("TEST 3: SIGNAL RECOVERY")
    print("‚îÅ" * 65)
    print("üëâ Stop moving and stay still...")

    signal_recovered = False
    timeout_secs = 15
    deadline = time.time() + timeout_secs
    while time.time() < deadline:
        state = "HIGH üî¥" if sensor.is_motion_detected() else "LOW  üü¢"
        print(f"\r   Signal: {state} | {int(deadline - time.time())}s", end="", flush=True)
        # require 3 consecutive LOWs to consider signal recovered
        if not sensor.is_motion_detected():
            time.sleep(0.05)
            if not sensor.is_motion_detected():
                time.sleep(0.05)
                if not sensor.is_motion_detected():
                    signal_recovered = True
                    print(f"\r[{ts()}] ‚úì Signal returned to LOW                ")
                    break
        time.sleep(0.05)

    test3_pass = signal_recovered
    if test3_pass:
        print(f"[{ts()}] ‚úÖ TEST 3 PASSED - Signal recovery working!")
    else:
        print(f"\r[{ts()}] ‚ö†Ô∏è  TEST 3 WARNING - Signal still HIGH (Tx delay high)")
    print()

    sensor.cleanup()
    # ... final-report unchanged ...
    return test2_pass
