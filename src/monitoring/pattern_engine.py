#!/usr/bin/env python3
"""
Pattern Engine - Anomaly Detection for Raspberry Pi Smart Monitoring Kit.

Analyzes sensor events to detect patterns and anomalies:
- Normal patterns (door open + motion = normal entry)
- Anomalies (vibration without door = potential break-in)
- Temperature anomalies (sudden changes)
- Time-based patterns (unusual activity at night)

Author: A.R. Ansari
Project: Raspberry Pi Smart Monitoring Kit
Client: Yoshinori Ueda
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import List, Optional, Callable, Dict, Any
from enum import Enum
from collections import deque


class EventType(Enum):
    """Types of sensor events."""
    MOTION = "motion"
    SOUND = "sound"
    DOOR_OPENED = "door_opened"
    DOOR_CLOSED = "door_closed"
    VIBRATION = "vibration"
    TEMP_HIGH = "temp_high"
    TEMP_LOW = "temp_low"
    HUMIDITY_HIGH = "humidity_high"
    HUMIDITY_LOW = "humidity_low"


class AlertLevel(Enum):
    """Alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    ALERT = "alert"
    CRITICAL = "critical"


@dataclass
class SensorEvent:
    """Represents a sensor event."""
    event_type: EventType
    timestamp: datetime = field(default_factory=datetime.now)
    sensor_data: Dict[str, Any] = field(default_factory=dict)

    def __str__(self) -> str:
        return f"[{self.timestamp.strftime('%H:%M:%S')}] {self.event_type.value}"


@dataclass
class Alert:
    """Represents an alert generated by pattern engine."""
    level: AlertLevel
    message: str
    event_type: EventType
    timestamp: datetime = field(default_factory=datetime.now)
    details: Dict[str, Any] = field(default_factory=dict)

    def __str__(self) -> str:
        return f"[{self.level.value.upper()}] {self.message}"


@dataclass
class PatternConfig:
    """Configuration for pattern detection."""
    # Temperature thresholds
    temp_high: float = 35.0
    temp_low: float = 10.0
    humidity_high: float = 80.0
    humidity_low: float = 20.0

    # Time windows
    event_correlation_window: float = 5.0  # seconds
    night_start_hour: int = 22  # 10 PM
    night_end_hour: int = 6    # 6 AM

    # Sensitivity
    vibration_without_door_alert: bool = True
    night_motion_alert: bool = True
    sound_alert: bool = True


class PatternEngine:
    """
    Analyzes sensor events to detect patterns and anomalies.

    Patterns detected:
    - Normal entry: door opens, then motion
    - Break-in attempt: vibration or sound without door
    - Night activity: motion during night hours
    - Environmental anomaly: temp/humidity out of range
    """

    def __init__(
        self,
        config: Optional[PatternConfig] = None,
        alert_callback: Optional[Callable[[Alert], None]] = None,
        logger=None
    ):
        self.config = config or PatternConfig()
        self.alert_callback = alert_callback
        self.logger = logger

        # Event history (last 100 events)
        self._events: deque = deque(maxlen=100)
        self._alerts: List[Alert] = []

        # State tracking
        self._door_open = False
        self._last_door_time: Optional[datetime] = None

    def process_event(self, event_type: str, sensor_data: Dict[str, Any]) -> Optional[Alert]:
        """
        Process a sensor event and check for patterns/anomalies.

        Args:
            event_type: Type of event (motion, sound, door_opened, etc.)
            sensor_data: Current sensor readings

        Returns:
            Alert if anomaly detected, None otherwise
        """
        try:
            evt_type = EventType(event_type)
        except ValueError:
            return None

        event = SensorEvent(
            event_type=evt_type,
            timestamp=datetime.now(),
            sensor_data=sensor_data
        )
        self._events.append(event)

        # Update door state
        if evt_type == EventType.DOOR_OPENED:
            self._door_open = True
            self._last_door_time = event.timestamp
        elif evt_type == EventType.DOOR_CLOSED:
            self._door_open = False
            self._last_door_time = event.timestamp

        # Analyze event for patterns/anomalies
        alert = self._analyze_event(event)

        if alert:
            self._alerts.append(alert)
            if self.alert_callback:
                self.alert_callback(alert)

        return alert

    def _analyze_event(self, event: SensorEvent) -> Optional[Alert]:
        """Analyze event for patterns and anomalies."""

        # Check for vibration without door activity (potential break-in)
        if event.event_type == EventType.VIBRATION:
            if self.config.vibration_without_door_alert:
                if not self._recent_door_activity():
                    return Alert(
                        level=AlertLevel.ALERT,
                        message="‚ö†Ô∏è Vibration detected without door activity!",
                        event_type=event.event_type,
                        details={"pattern": "potential_intrusion"}
                    )

        # Check for night motion
        if event.event_type == EventType.MOTION:
            if self.config.night_motion_alert and self._is_night_time():
                return Alert(
                    level=AlertLevel.WARNING,
                    message="üåô Motion detected during night hours",
                    event_type=event.event_type,
                    details={"pattern": "night_activity"}
                )

        # Check for sound without door activity
        if event.event_type == EventType.SOUND:
            if self.config.sound_alert and not self._recent_door_activity():
                return Alert(
                    level=AlertLevel.WARNING,
                    message="üîä Unusual sound detected",
                    event_type=event.event_type,
                    details={"pattern": "unexpected_sound"}
                )

        # Check door opened (informational)
        if event.event_type == EventType.DOOR_OPENED:
            level = AlertLevel.WARNING if self._is_night_time() else AlertLevel.INFO
            emoji = "üö™üåô" if self._is_night_time() else "üö™"
            return Alert(
                level=level,
                message=f"{emoji} Door opened",
                event_type=event.event_type,
                details={"night": self._is_night_time()}
            )

        return None

    def check_temperature(self, temp: float, humidity: float) -> Optional[Alert]:
        """Check temperature and humidity for anomalies."""
        if temp > self.config.temp_high:
            return Alert(
                level=AlertLevel.WARNING,
                message=f"üå°Ô∏è High temperature: {temp:.1f}¬∞C",
                event_type=EventType.TEMP_HIGH,
                details={"temperature": temp}
            )

        if temp < self.config.temp_low:
            return Alert(
                level=AlertLevel.WARNING,
                message=f"‚ùÑÔ∏è Low temperature: {temp:.1f}¬∞C",
                event_type=EventType.TEMP_LOW,
                details={"temperature": temp}
            )

        if humidity > self.config.humidity_high:
            return Alert(
                level=AlertLevel.INFO,
                message=f"üíß High humidity: {humidity:.1f}%",
                event_type=EventType.HUMIDITY_HIGH,
                details={"humidity": humidity}
            )

        if humidity < self.config.humidity_low:
            return Alert(
                level=AlertLevel.INFO,
                message=f"üèúÔ∏è Low humidity: {humidity:.1f}%",
                event_type=EventType.HUMIDITY_LOW,
                details={"humidity": humidity}
            )

        return None

    def _recent_door_activity(self) -> bool:
        """Check if door was opened/closed recently."""
        if self._last_door_time is None:
            return False
        elapsed = (datetime.now() - self._last_door_time).total_seconds()
        return elapsed < self.config.event_correlation_window

    def _is_night_time(self) -> bool:
        """Check if current time is during night hours."""
        hour = datetime.now().hour
        if self.config.night_start_hour > self.config.night_end_hour:
            # Night spans midnight (e.g., 22:00 - 06:00)
            return hour >= self.config.night_start_hour or hour < self.config.night_end_hour
        else:
            return self.config.night_start_hour <= hour < self.config.night_end_hour

    def get_recent_events(self, count: int = 10) -> List[SensorEvent]:
        """Get most recent events."""
        return list(self._events)[-count:]

    def get_recent_alerts(self, count: int = 10) -> List[Alert]:
        """Get most recent alerts."""
        return self._alerts[-count:]

    def clear_history(self) -> None:
        """Clear event and alert history."""
        self._events.clear()
        self._alerts.clear()
